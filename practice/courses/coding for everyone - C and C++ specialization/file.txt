Okay, we've completed explaining some of the critical details of this code. But now let's see the code and detail and make sure it works. So, We're going to create a variable for each kind of item, each character we're trying to count blanks, digits, letters, others since we don't have a count yet. All of them will be initialized to zero. And then we're going to use C to indicate the integer value of the character. And remember, characters are ordinary C are somewhere between 0 and 127. And that's the standard ASCII character table which you should get familiar with if you haven't until now. And this is a very convenient thing. We're going to find from the standard Library. We can find it in standard IO, and that is the getchar function. No arguments, and what it does is it obtains from standard input which is in this case going to end up being a file because we're going to redirect. But it could also be a typing of from the keyboard if we don't do the direction. And here we test to see if we're at the end of file, and this is, C, any end of file and that's a constant. It's typically -1 but it's a previously defined constant, which is a special value that would otherwise not be in the file. So -1 is outside the range of the ASCII characters. And we're just continuing that iteration, that loop, until we hit the end of file. Here we see a complex if else if statement, inside the while loop. Notice I've made the while loop a compound statement, but that was unnecessary. It's just stylistically nice, even though this is actually a single if-else statement. So it was unnecessary. Here's if, C equal blanks then we auto increment blanks. If it isn't a blank, we test to see if it's the integers between 0 and 9 and that's that range is strictly. If you go to the ASCII table strictly those values, and here is a more complicated expression, we'll talk a little bit about it. It's the lowercase letters, but somewhere else are the uppercase letters. So we couldn't just say if C lowercase a up to z should be a lot of stuff in between, but these are all contiguous. Again, you have the only way you know that it's by looking at it in the ASCII table. So this is one range and also you'll notice that the double Ampersand is logical end. And that takes precedence over the double single bar which is the logical or. So this sub expression gets done first. If that's true, then this doesn't get done. Again, the way these expressions work, this is what's called short circuit evaluation. You can look that up. If you don't remember an explanation, it just means we only need to test this if it's true. Then an or expression will always be true. If this fails then we have to test the second part. And similarly short circuit works with the and parts. If this little part is false, then it fails for the entire expression that's called short circuit. So we don't have to do the extra work. And we have blanks incremented digits instrumented letters and fermented others. And you can do something even more elaborate if you had some interest in developing this program further. And then here we just print out their values. So I'm going to run this program as I showed in the previous segment. I'm going to use redirection and I'm going to, Run it on a file which indeed is the program you saw at the beginning. And that program had a 196 blanks, 17 digits, 302 letters, and otherwise had a 152 other things sitting in as characters, which could include things like new lines and tabs. So they could be non-printable characters as well as printable characters.
